<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Api\BaseController;
use Illuminate\Http\Request;
use App\Services\Payment\StripeService;
use App\Models\UserPaymentMethod;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Auth;
use Stripe\PaymentMethod;

class PaymentController extends BaseController
{
    public function __construct(private StripeService $stripe) {}

    /**
     * Add a card (Stripe payment_method) for the authenticated user (customer or provider).
     * Body: { "payment_method_id": "pm_xxx", "make_default": true/false }
     */
    public function addCard1(Request $request)
    {
        $data = $request->validate([
            'payment_method_id' => 'required|string',
            'make_default' => 'sometimes|boolean',
        ]);

        $user = Auth::user();
        $makeDefault = (bool) ($data['make_default'] ?? false);

        $customerId = $this->stripe->ensureCustomer($user);

        try {
            $paymentMethod = $this->stripe->attachPaymentMethod(
                customerId: $customerId,
                paymentMethodId: $data['payment_method_id'],
                makeDefault: $makeDefault
            );
        } catch (\Throwable $e) {
            return $this->sendError('Stripe error: '.$e->getMessage(), 422);
        }

        $card = $paymentMethod->card;

        $record = DB::transaction(function () use ($user, $paymentMethod, $card, $makeDefault) {
            if ($makeDefault) {
                UserPaymentMethod::where('user_id', $user->id)->update(['is_default' => false]);
            }

            return UserPaymentMethod::updateOrCreate(
                [
                    'user_id' => $user->id,
                    'stripe_payment_method_id' => $paymentMethod->id,
                ],
                [
                    'brand' => $card->brand ?? null,
                    'last4' => $card->last4 ?? null,
                    'exp_month' => $card->exp_month ?? null,
                    'exp_year' => $card->exp_year ?? null,
                    'is_default' => $makeDefault,
                ]
            );
        });

        return $this->sendResponse($record, 'Card added successfully.');
    }
    public function addCard(Request $request)
    {
        $request->validate([
            'payment_method_id' => 'required|string',
            'make_default' => 'sometimes|boolean',
        ]);

        $user = Auth::user();
        $makeDefault = (bool)($request->make_default ?? false);

        // ⚠️ PaymentMethod ALREADY attached via SetupIntent
        $pm = \Stripe\PaymentMethod::retrieve(
            $request->payment_method_id
        );
        if ($pm->customer !== $user->stripe_customer_id) {
            return $this->sendError(
                'Payment method is not attached to this customer.',
                422
            );
        }
        DB::transaction(function () use ($user, $pm, $makeDefault) {
            if ($makeDefault) {
                UserPaymentMethod::where('user_id', $user->id)
                    ->update(['is_default' => false]);
            }

            UserPaymentMethod::updateOrCreate(
                [
                    'user_id' => $user->id,
                    'stripe_payment_method_id' => $pm->id,
                ],
                [
                    'brand' => $pm->card->brand,
                    'last4' => $pm->card->last4,
                    'exp_month' => $pm->card->exp_month,
                    'exp_year' => $pm->card->exp_year,
                    'is_default' => $makeDefault,
                ]
            );
        });

        if ($makeDefault) {
            $this->stripe->setDefaultPaymentMethod(
                $user->stripe_customer_id,
                $pm->id
            );
        }

        return $this->sendResponse([], 'Card added successfully.');
    }

    /**
     * List cards for current user.
     */
    public function listCards()
    {
        $cards = UserPaymentMethod::where('user_id', Auth::id())
            ->orderByDesc('is_default')
            ->latest()
            ->get();

        return $this->sendResponse($cards, 'Cards fetched successfully.');
    }

    /**
     * Set a card as default for current user.
     */
    public function makeDefault1($id)
    {
        $card = UserPaymentMethod::where('user_id', Auth::id())
            ->whereKey($id)
            ->first();

        if (empty($card)) {
            return $this->sendError('Card not found.', 404);
        }
        $user = Auth::user();
        $customerId = $this->stripe->ensureCustomer($user);

        try {
            $this->stripe->attachPaymentMethod($customerId, $card->stripe_payment_method_id, true);
        } catch (\Throwable $e) {
            return $this->sendError('Stripe error: '.$e->getMessage(), 422);
        }

        DB::transaction(function () use ($card) {
            UserPaymentMethod::where('user_id', $card->user_id)
                ->where('id', '!=', $card->id)
                ->update(['is_default' => false]);
            $card->update(['is_default' => true]);
        });

        return $this->sendResponse([], 'Default card updated.');
    }
    public function makeDefault($id)
    {
        $card = UserPaymentMethod::where('user_id', Auth::id())
            ->whereKey($id)
            ->first();

        if (!$card) {
            return $this->sendError('Card not found.', 404);
        }

        $user = Auth::user();
        $customerId = $this->stripe->ensureCustomer($user);

        // ✅ ONLY set default
        $this->stripe->setDefaultPaymentMethod(
            $customerId,
            $card->stripe_payment_method_id
        );

        DB::transaction(function () use ($card) {
            UserPaymentMethod::where('user_id', $card->user_id)
                ->update(['is_default' => false]);

            $card->update(['is_default' => true]);
        });

        return $this->sendResponse([], 'Default card updated.');
    }

    /**
     * TEST ONLY: Create a test payment_method using Stripe test token.
     * Use this to get a valid payment_method_id for testing addCard API.
     * Body: { "test_token": "tok_visa" } (optional, defaults to tok_visa)
     */
    public function createTestPaymentMethod(Request $request)
    {
        $testToken = $request->input('test_token', 'tok_visa'); // Default Stripe test token

        try {
            $paymentMethod = PaymentMethod::create([
                'type' => 'card',
                'card' => ['token' => $testToken],
            ]);

            return $this->sendResponse([
                'payment_method_id' => $paymentMethod->id,
                'message' => 'Test payment_method created. Use this payment_method_id in addCard API.',
            ], 'Test payment_method created successfully.');
        } catch (\Throwable $e) {
            return $this->sendError('Stripe error: '.$e->getMessage(), 422);
        }
    }
    public function retryPayment(Request $request)
    {
        $request->validate([
            'payment_intent_id' => 'required|string',
            'payment_method_id' => 'required|string',
        ]);

        try {
            $intent = $this->stripe->retryPayment(
                $request->payment_intent_id,
                $request->payment_method_id
            );

            return $this->sendResponse($intent, 'Payment retried successfully.');
        } catch (\Stripe\Exception\CardException $e) {
            return $this->sendError(
                $e->getError()->message ?? 'Payment requires action',
                402
            );
        }
    }
}


<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use App\Models\Booking;
use App\Models\Transaction;
use App\Services\Notification\NotificationService;
use Stripe\Webhook;
use Illuminate\Support\Facades\DB;  
use Stripe\Event; 
use Illuminate\Support\Facades\Log;
use Stripe\Exception\SignatureVerificationException;

class StripeWebhookController extends Controller
{
    public function __construct(private NotificationService $notificationService) {}

    public function handle(Request $request)
    {
        $payload   = $request->getContent();
        $sigHeader = $request->header('Stripe-Signature');
        $secret    = config('services.stripe.webhook_secret'); 
                 
        try {
            $event = Webhook::constructEvent($payload, $sigHeader, $secret);
        } catch (\UnexpectedValueException $e) {
            return response('Invalid payload', 400);
        } catch (SignatureVerificationException $e) {
            return response('Invalid signature', 400);
        }

        switch ($event->type) {
            case 'payment_intent.succeeded':
                $pi = $event->data->object;
                DB::transaction(function () use ($pi) {
                    // Update booking
                    $booking = Booking::where('stripe_payment_intent_id', $pi->id)
                        ->whereNull('paid_at')
                        ->first();
                    
                    if ($booking) {
                        $booking->update(['paid_at' => now()]);
                    }
                    
                    // Update transaction
                    $transaction = Transaction::where('stripe_payment_intent_id', $pi->id)
                        ->where('status', '!=', 'succeeded')
                        ->first();
                    
                    if ($transaction) {
                        $transaction->update([
                            'status' => 'succeeded',
                            'completed_at' => now(),
                            'stripe_charge_id' => $pi->charges->data[0]->id ?? null,
                        ]);
                        
                        // Send notifications
                        $this->notificationService->notifyPaymentSuccess($transaction);
                        // $this->notificationService->notifyPaymentSuccessful($transaction);
                    }
                });
                break;
            case 'payment_intent.requires_payment_method':

                $pi = $event->data->object;

                DB::transaction(function () use ($pi) {
                    $transaction = Transaction::where(
                        'stripe_payment_intent_id',
                        $pi->id
                    )->first();

                    if ($transaction) {
                        $transaction->update([
                            'status' => 'requires_payment_method',
                            'failure_reason' =>
                                $pi->last_payment_error->message ?? 'Payment requires new method',
                        ]);
                    }
                });
                break;
            case 'payment_intent.payment_failed':
                $pi = $event->data->object;
                DB::transaction(function () use ($pi) {
                    $transaction = Transaction::where('stripe_payment_intent_id', $pi->id)
                        ->where('status', '!=', 'failed')
                        ->first();
                    
                    if ($transaction) {
                        $transaction->update([
                            'status' => 'failed',
                            'failed_at' => now(),
                            'failure_reason' => $pi->last_payment_error->message ?? 'Payment failed',
                        ]);
                        
                        // Send notification
                        $this->notificationService->notifyPaymentFailed($transaction);
                    }
                });
                break;

            case 'refund.succeeded':
                $charge = $event->data->object;
                if (!empty($charge->payment_intent)) {
                    DB::transaction(function () use ($charge) {
                        $booking = Booking::where('stripe_payment_intent_id', $charge->payment_intent)
                            ->first();
                        
                        if ($booking) {
                            $booking->update(['status' => 'refunded']);
                        }
                        
                        $transaction = Transaction::where('stripe_payment_intent_id', $charge->payment_intent)
                            ->first();
                        
                        if ($transaction) {
                            $transaction->update(['status' => 'refunded']);
                            
                            // Create refund transaction
                            $refundTransaction = Transaction::create([
                                'booking_id' => $transaction->booking_id,
                                'customer_id' => $transaction->customer_id,
                                'provider_id' => $transaction->provider_id,
                                'transaction_ref' => Transaction::generateRef(),
                                'type' => 'refund',
                                'status' => 'succeeded',
                                'amount' => $charge->amount_refunded / 100,
                                'service_charges' => 0,
                                'net_amount' => $charge->amount_refunded / 100,
                                'currency' => $charge->currency,
                                'stripe_charge_id' => $charge->id,
                                'completed_at' => now(),
                            ]);
                            
                            // Send notification
                            $this->notificationService->notifyRefundProcessed($refundTransaction);
                        }
                    });
                }
                break;

            // add more events if needed
        }

        return response()->json(['status' => 'ok']);
    }
}

<?php
namespace App\Services\Booking;

use App\Models\User;
use App\Models\Booking;
use App\Models\BookingSlot;
use App\Models\ProviderWorkingHour;
use App\Models\BookingReschedule;
use App\Models\ProviderService;
use App\Models\Review;
use App\Models\Transaction;
use App\Models\UserPaymentMethod;

use Carbon\Carbon;
use Illuminate\Support\Str; 
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Log;
use App\Services\Payment\StripeService;
use App\Services\Notification\NotificationService;
use Illuminate\Support\Facades\DB; 

use App\Models\Setting;

class BookingService
{

 
    public function __construct(
        private StripeService $stripe,
        private NotificationService $notificationService
    ) {}

    public function checkAvailability(array $slot, int $providerId): string
    {
        $dayName = strtolower(Carbon::parse($slot['service_date'])->format('l'));
           
        // 1. Get provider working hours
        $workingHour = ProviderWorkingHour::where('user_id', $providerId)
            ->where('day', $dayName)
            ->first();
            
            
         
        if (!$workingHour || !$workingHour->is_active) {
            return 'not_available';
        }       
        // 2. Validate slot inside working hours
        // if (
        //     $slot['start_time'] < $workingHour->start_time ||
        //     $slot['end_time'] > $workingHour->end_time
        //     ) {
                
                 
        //         return 'not_available';
        //     }

        // 3. Check if provider is fully booked
        if ($this->providerHasConflict($providerId, $slot['service_date'], $slot['start_time'], $slot['end_time']
        )) {
            return 'fully_booked';
        }  

        return 'available';
    }

    public function providerHasService($providerId, $serviceId) 
    {
         
        $providerHasService = ProviderService::where('user_id', $providerId)
            ->where('service_id', $serviceId)
            ->first() ;
        return ['status'=>$providerHasService ? true : false, 'data'=>$providerHasService];
         
        // return $providerHasService ? true : false;
            
    }
    public function create(array $data) 
    {
         
        $totalMinutes = 0; 
        $providerIsAvailable = $this->providerIsAvailable(
            $data['provider_id']
        );

         
        $providerHasService = $this->providerHasService($data['provider_id'], $data['service_id']);
        if (!$providerHasService['status']) {
            return [
                'error' => true,
                'message' => 'Provider does not offer this service.'
            ];
            
        } 
        if ($providerIsAvailable == false) {
            return [
                'error' => true,
                'message' => 'Provider is not available.'
            ];
        }   



        foreach ($data['slots'] as $slot) {
            $status = $this->checkAvailability($slot, $data['provider_id']); 
             
            if ($status !== 'available') {
                return [
                    'error' => true,
                    'message' => "Provider is not available on {$slot['service_date']} between {$slot['start_time']} - {$slot['end_time']}."
                ]; 
            }  
             
            $duration = $this->minutesBetween($slot['start_time'], $slot['end_time']);
             
            if ($duration <= 0) {
                return [
                    'error' => true,
                    'message' => 'Invalid slot duration.'
                ];   
            }
            
            $totalMinutes += $duration;
             
             
             
        }         
        $pricingResult = $this->resolveBookingPricing($data, $totalMinutes);
        if ($pricingResult['error']) {
            return $pricingResult;
        }
        
        $data['total_price'] = $pricingResult['total_price'];
        $data['booking_type'] = $pricingResult['booking_type'];
        $hourlyRateUsed = $pricingResult['hourly_rate'] ?? null;
         

        // Stripe charge (in cents)
        $amountCents = (int) round($data['total_price'] * 100);
         
        // $intent = $this->stripe->createAndConfirmIntent(
        //     amountCents: $amountCents,
        //     currency: 'usd',
        //     paymentMethodId: $data['payment_method_id'],
        //     metadata: [
        //         'customer_id' => (string)auth()->user()->id,
        //         'provider_id' => (string)$data['provider_id'],
        //     ]
        // );
        
        // Payment might be requires_action in rare cases; handle by client if needed
        // if (!in_array($intent->status, ['succeeded', 'requires_action'])) {
        //     return [
        //         'error' => true,
        //         'message' => 'Payment could not be confirmed'
        //     ];  
        // }
          
        // Persist booking + slots
        return DB::transaction(function () use ($data, $totalMinutes,$providerHasService,$hourlyRateUsed) {
            // Calculate service charges dynamically based on admin settings
            $percentage = (float) \App\Models\Setting::get('service_charge_percentage', 25); 
            $serviceCharges = ($data['total_price'] * $percentage) / 100;
              
            $booking = Booking::create([
                'booking_ref' => $this->makeRef(),
                'customer_id' => auth()->user()->id,
                'provider_id' => $data['provider_id'],
                'service_id' => $data['service_id'],
                'provider_service_id' => $providerHasService['data']->id ,
                'booking_address' => $data['booking_address'],
                'booking_description' => $data['booking_description'] ?? null,
                'status' => 'awaiting_provider',
                'booking_type' => $data['booking_type'] ?? 'hourly',
                'hourly_rate' => $hourlyRateUsed,
                'booking_working_minutes' => $totalMinutes,
                'total_price' => $data['total_price'] ,
                'service_charges' => $serviceCharges,
                // 'stripe_payment_intent_id' => $intent->id,
                // 'stripe_payment_method_id' => $data['payment_method_id'],
                // 'paid_at' => $intent->status === 'succeeded' ? now() : null,
                // 'paid_at' => null,
                'expires_at' => now()->addHours(2),
            ]);

            foreach ($data['slots'] as $slot) {
                BookingSlot::create([
                    'booking_id' => $booking->id,
                    'service_date' => $slot['service_date'],
                    'start_time' => $slot['start_time'],
                    'end_time' => $slot['end_time'],
                    'duration_minutes' => $this->minutesBetween($slot['start_time'], $slot['end_time']),
                ]);
            }

            $booking = $booking->load('slots','customer','provider','providerService.service', 'review');
            
            // Send notifications
            // notifyNewBookingCreated sends to admin only
            // notifyBookingCreated sends to provider, customer, and admin
            // So we only need notifyBookingCreated to avoid duplicate admin notifications
            $this->notificationService->notifyBookingCreated($booking);

            // Add review status
            $booking = $this->addReviewStatus($booking);

            return $booking;
        });
    }

    public function directCreate(array $data)
    {
        return DB::transaction(function () use ($data) {
            // 1. Check if provider offers the service
            $providerService = ProviderService::where('user_id', $data['provider_id'])
                ->where('service_id', $data['service_id'])
                ->first();

            // if (!$providerService) {
            //     return ['error' => true, 'message' => 'Provider does not offer this service.'];
            // }

            // 2. Calculate total minutes and check slot conflicts
            $totalMinutes = 0;
            foreach ($data['slots'] as $slot) {
                $start = Carbon::createFromFormat('H:i', $slot['start_time']);
                $end = Carbon::createFromFormat('H:i', $slot['end_time']);
                $duration = $start->diffInMinutes($end);

                if ($duration <= 0) {
                    return ['error' => true, 'message' => 'Invalid slot duration for ' . $slot['service_date']];
                }

                $totalMinutes += $duration;

                // Check for conflicts with other bookings
                // $hasConflict = DB::table('booking_slots as bs')
                //     ->join('bookings as b', 'b.id', '=', 'bs.booking_id')
                //     ->where("b.provider_id", $data['provider_id'])
                //     ->whereIn('b.status', ['awaiting_provider', 'confirmed', 'in_progress'])
                //     ->whereDate('bs.service_date', $slot['service_date'])
                //     ->where(function ($q) use ($slot) {
                //         $q->where('bs.start_time', '<', $slot['end_time'])
                //             ->where('bs.end_time', '>', $slot['start_time']);
                //     })
                //     ->exists();

                // if ($hasConflict) {
                //     return ['error' => true, 'message' => "Provider is already booked on {$slot['service_date']} between {$slot['start_time']} - {$slot['end_time']}."];
                // }
            }

            // 3. Calculate service charges (admin commission)
            $percentage = (float) Setting::get('service_charge_percentage', 25);
            $serviceCharges = ($data['total_price'] * $percentage) / 100;

            // 4. Create the booking with 'confirmed' status
            $booking = Booking::create([
                'booking_ref' => $this->makeRef(),
                'customer_id' => $data['customer_id'],
                'provider_id' => $data['provider_id'],
                'service_id' => $data['service_id'],
                'provider_service_id' => $providerService ? $providerService->id : null,
                'booking_address' => $data['booking_address'],
                'booking_description' => $data['booking_description'] ?? null,
                'status' => 'confirmed', // Automatically accepted
                'booking_type' => 'custom',
                'booking_working_minutes' => $totalMinutes,
                'total_price' => $data['total_price'],
                'service_charges' => $serviceCharges,
                'confirmed_at' => now(),
                'expires_at' => now()->addHours(2), // Standard expiry
            ]);

            // 5. Create slots
            foreach ($data['slots'] as $slot) {
                BookingSlot::create([
                    'booking_id' => $booking->id,
                    'service_date' => $slot['service_date'],
                    'start_time' => $slot['start_time'],
                    'end_time' => $slot['end_time'],
                    'duration_minutes' => Carbon::createFromFormat('H:i', $slot['start_time'])
                        ->diffInMinutes(Carbon::createFromFormat('H:i', $slot['end_time'])),
                ]);
            }

            $booking = $booking->load('slots', 'customer', 'provider', 'providerService.service');

            return ['error' => false, 'booking' => $booking];
        });
    }

    public function accept(Booking $booking) 
    {
        if ($booking->status !== 'awaiting_provider') {
            return [
                'error' => true,
                'message' => 'Booking not awaiting provider.'
            ];  
        }
        $booking->update(['status' => 'confirmed', 'confirmed_at' => now()]);
        $booking = $booking->fresh('slots', 'provider', 'customer','providerService.service', 'review');
        
        // Send notification
        $this->notificationService->notifyBookingConfirmed($booking);
        
        // Add review status
        $booking = $this->addReviewStatus($booking);
        
        return $booking;
    }

    public function reject(Booking $booking) 
    {
        if ($booking->status !== 'awaiting_provider') {
            return [
                'error' => true,
                'message' => 'Booking not awaiting provider.'
            ];
             
        }
        
        if ($booking->stripe_payment_intent_id) {
            $this->stripe->refundByPaymentIntent($booking->stripe_payment_intent_id);
        }

        $booking->update(['status' => 'rejected','rejected_at' => now()]);
        $booking = $booking->fresh('slots', 'provider', 'customer','providerService.service');
        
        // Send notification
        $this->notificationService->notifyBookingRejected($booking);
        
        return $booking;
    }
    public function start(Booking $booking) 
    {
        if ($booking->status !== 'confirmed') {
             return [
                'error' => true,
                'message' => 'Only confirmed bookings can be started.'
            ]; 
        } 
        
        $booking->update(['status' => 'in_progress', 'started_at' => now()]);
        $booking = $booking->fresh('slots', 'provider', 'customer','providerService.service');
        
        // Send notification
        $this->notificationService->notifyBookingStarted($booking);
        
        return $booking;
    }

    public function cancel(Booking $booking, string $cancelReason){
        // if ($booking->status !== 'in_progress') {
        //      return [
        //         'error' => true,
        //         'message' => 'Only in progress bookings can be cancelled.'
        //     ]; 
        // } 
        $cancelledBy = Auth::id() === $booking->customer_id ? 'customer' : 'provider';
        $booking->update(['status' => 'cancelled', 'cancelled_at' => now(), 'cancelled_reason' => $cancelReason]);
        $booking = $booking->load('slots', 'provider', 'customer','providerService.service');
        
        // Send notification
        $this->notificationService->notifyBookingCancelled($booking, $cancelledBy);
        
        return $booking;
    }
    public function complete(Booking $booking) 
    {
        if ($booking->status !== 'in_progress') {
             return [
                'error' => true,
                'message' => 'Only in progress bookings can be completed.'
            ]; 
        }
        $booking->update(['status' => 'completed', 'completed_at' => now()]);
        $booking = $booking->fresh('slots', 'provider', 'customer','providerService.service', 'review');
        
        // Send notifications
        $this->notificationService->notifyJobCompleted($booking);
        
        // Add review status
        $booking = $this->addReviewStatus($booking);
        
        return $booking;
    }

    public function requestReschedule(Booking $booking, array $newSlots): array
    {
         
        if ($booking->status !== 'confirmed') {
             
            return [
                'error' => true,
                'message' => 'Only confirmed bookings can be rescheduled.'
            ];  
        }
        
        if (BookingReschedule::where('booking_id', $booking->id)->where('status', 'pending')->exists()) {
            return [
                'error' => true,
                'message' => 'A reschedule request is already pending.'
            ]; 
        }

        $reschedule = BookingReschedule::create([
            'booking_id'   => $booking->id,
            'requested_by' => Auth::id(),
            'old_slots'    => $booking->slots->toArray(),
            'new_slots'    => $newSlots,            
            'status'       => 'pending',
        ]);

        $isCustomer = Auth::id() === $booking->customer_id;
        $booking->update([ 
            'reschedule_initiated_by' => $isCustomer ? 'customer' : 'provider',
            'reschedule_response' => null, // Reset response when new request is made
        ]);
        
        // Send notification
        $this->notificationService->notifyRescheduleRequested($booking, $reschedule, $isCustomer ? 'customer' : 'provider');
        
        return [
            'error' => false, 
            'reschedule' => $reschedule,
            'booking'    => $booking
        ];
    }

    public function respondReschedule(Booking $booking, string $response): array
    {
        $totalMinutes = 0;
        $reschedule = BookingReschedule::where('booking_id', $booking->id)
            ->where('status', 'pending')
            ->latest()
            ->first();
         
        if (!$reschedule) {
            return [
                'error' => true,
                'message' => 'No pending reschedule request found.'
            ] ;
        }
        if ($response === 'accept') {
            foreach ($reschedule->new_slots as $slot) {
                 
                $status = $this->checkAvailability($slot, $booking['provider_id']);
                 
                if ($status !== 'available') {
                    return [
                        'error' => true,
                        'message' => "Provider already booked on {$slot['service_date']} between {$slot['start_time']} - {$slot['end_time']}."
                    ]; 
                }  
                 
                $duration = $this->minutesBetween($slot['start_time'], $slot['end_time']);
                  
                if ($duration <= 0) {
                    return [
                        'error' => true,
                        'message' => 'Invalid slot duration.'
                    ];   
                }
                
                $totalMinutes += $duration;
                 
                 
                 
            }         
              
            $booking->slots()->delete();
            foreach ($reschedule->new_slots as $slot) {
                $duration = $this->minutesBetween($slot['start_time'], $slot['end_time']);
                $slot['duration_minutes'] = $duration;
                $booking->slots()->create($slot);
            }
            
             
            $booking->update([
                'status' => 'confirmed',
                'reschedule_response' => 'accepted',
            ]);
            $reschedule->update(['status' => 'accepted']);
            
            // Send notification
            $this->notificationService->notifyRescheduleAccepted($booking, $reschedule);

        } elseif ($response === 'reject') {
            
            $reschedule->update(['status' => 'rejected']);
            
             
            $booking->update([
                'reschedule_response' => 'rejected',
            ]);
            
            // Send notification
            $this->notificationService->notifyRescheduleRejected($booking, $reschedule);

        } else {
            return [
                'error' => true,
                'message' => 'Invalid response option.'
            ]; 
        }

        return [
            'error' => false, 
            'reschedule' => $reschedule,
            'booking'    => $booking
        ];
    }
    public function autoRejectExpired(): int
    {
        $query = Booking::query()
            ->where('status', 'awaiting_provider')
            ->where('expires_at', '<', now());

        $count = 0;
        $query->chunkById(100, function ($bookings) use (&$count) {
            foreach ($bookings as $booking) {
                try {
                    $this->reject($booking);
                    $this->notificationService->notifyBookingExpired($booking);
                    $count++;
                } catch (\Throwable) {}
            }
        });

        return $count;
    }

    private function minutesBetween(string $start, string $end): int
    {
         
        $s = Carbon::createFromFormat('H:i', $start);
        $e = Carbon::createFromFormat('H:i', $end);

         
        return $s->diffInMinutes($e);
    }

    private function resolveBookingPricing(array $data, int $totalMinutes): array
    {
        $bookingType = $data['booking_type'] ?? 'hourly';

        if ($bookingType === 'hourly') {
            if (!isset($data['hourly_rate'])) {
                return [
                    'error' => true,
                    'message' => 'Hourly rate is required for hourly bookings.',
                ];
            }

            $hourlyRate = (float) $data['hourly_rate'];
            if ($hourlyRate <= 0) {
                return [
                    'error' => true,
                    'message' => 'Hourly rate must be greater than zero.',
                ];
            }

            $totalPrice = $this->calculateHourlyPrice($hourlyRate, $totalMinutes);
            if ($totalPrice <= 0) {
                return [
                    'error' => true,
                    'message' => 'Calculated total price is invalid.',
                ];
            }
        } else {
            if (!isset($data['total_price'])) {
                return [
                    'error' => true,
                    'message' => 'Total price is required for custom bookings.',
                ];
            }

            $totalPrice = (float) $data['total_price'];
            if ($totalPrice <= 0) {
                return [
                    'error' => true,
                    'message' => 'Custom total price must be greater than zero.',
                ];
            }
        }

        return [
            'error' => false,
            'total_price' => round($totalPrice, 2),
            'booking_type' => $bookingType,
            'hourly_rate' => $bookingType === 'hourly' ? (float) $data['hourly_rate'] : null,
        ];
    }

    private function calculateHourlyPrice(float $hourlyRate, int $totalMinutes): float
    {
        $hours = $totalMinutes / 60;
        return round($hourlyRate * $hours, 2);
    }


    private function resolveCustomerPaymentMethod(int $userId, ?int $methodId): ?UserPaymentMethod
    {
        if ($methodId) {
            return UserPaymentMethod::where('user_id', $userId)
                ->where('id', $methodId)
                ->first();
        }

        $method = UserPaymentMethod::where('user_id', $userId)
            ->where('is_default', true)
            ->first();

        if ($method) {
            return $method;
        }

        return UserPaymentMethod::where('user_id', $userId)->latest()->first();
    }


    private function providerHasConflict(int $providerId, string $date, string $start, string $end,): bool
    {
        // Conflict if any existing booking (awaiting_provider or confirmed) overlaps
        return \DB::table('booking_slots as bs')
            ->join('bookings as b', 'b.id', '=', 'bs.booking_id')
            ->where("b.provider_id", $providerId)
            ->whereIn('b.status', ['awaiting_provider','confirmed'])
            ->whereDate('bs.service_date', $date)
            ->where(function ($q) use ($start, $end) {
                $q->where('bs.start_time', '<', $end)
                ->where('bs.end_time', '>', $start);
            })
        ->exists();
    }

    private function makeRef(): string
    {
        return 'FT-'.now()->format('Ymd').'-'.strtoupper(Str::random(6));
    }

    public function providerIsAvailable($providerId)
    {
        $provider = User::find($providerId); 
        if (!$provider || $provider->providerProfile->availability_status != 'available') {
            return false; 
        }
        return true;
    }
    public function job($providerId){
        $data['pending'] = $this->pendingBookingsProvider($providerId);
        $data['ongoing'] = $this->onGoingBookingsProvider($providerId);
        $data['upcoming'] = $this->upcomingBookingsProvider($providerId);
        $data['completed'] = $this->completedBookingsProvider($providerId);
        $data['totalAmount'] = $this->totalAmountProvider($providerId);
        return $data;
    }
    public function pendingBookingsProvider($providerId)
    {
        return Booking::with('slots', 'provider', 'customer','providerService.service')->where('provider_id', $providerId)->where('status', 'awaiting_provider')->paginate(10);
    }

    public function onGoingBookingsProvider($providerId)
    {
        return Booking::with('slots', 'provider', 'customer','providerService.service')->where('provider_id', $providerId)->where('status', 'in_progress')->first();
    }

    public function upcomingBookingsProvider($providerId)
    {
        return Booking::with('slots', 'provider', 'customer','providerService.service','latestPendingReschedule')->where('provider_id', $providerId)->where('status', 'confirmed')->paginate(10);
    }

    public function completedBookingsProvider($providerId)
    {
        return Booking::with('slots', 'provider', 'customer','providerService.service')->where('provider_id', $providerId)->where('status', 'completed')->paginate(10);
    }

    public function totalAmountProvider($providerId)
    {
         
        return Booking::where('provider_id', $providerId)->where('status', 'completed')->sum('total_price');
    }

    public function pendingBookingsCustomer($customerId)
    {
        return Booking::with('slots', 'provider', 'customer','providerService.service')->where('customer_id', $customerId)->where('status', 'awaiting_provider')->paginate(10);
    }
    public function upcomingBookingsCustomer($customerId)
    {
        $bookings = Booking::with('slots', 'provider', 'customer','providerService.service')
            ->where('customer_id', $customerId)
            ->where('status', 'confirmed')
            ->paginate(10);
        
        // Add late status for each booking
        foreach ($bookings as $booking) {
            $lateCheck = $this->isProviderLate($booking);
            $booking->setAttribute('is_provider_late', $lateCheck['is_late']);
            $booking->setAttribute('can_take_late_action', $lateCheck['can_take_action'] ?? false);
        }
        
        return $bookings;
    }

    public function completedBookingsCustomer($customerId)
    {
        $bookings = Booking::with('slots', 'provider', 'customer','providerService.service', 'review')
            ->where('customer_id', $customerId)
            ->where('status', 'completed')
            ->paginate(10);
        
        return $this->addReviewStatus($bookings);
    }

    public function cancelledBookingsCustomer($customerId)
    {
        return Booking::with('slots', 'provider', 'customer','providerService.service')
            ->where('customer_id', $customerId)
            ->whereIn('status', ['cancelled', 'rejected'])
            ->paginate(10);
    }

    public function processPayment(int $id, ?int $userPaymentMethodId = null): array
    {
        $booking = Booking::with('slots')->find($id);
        if (!$booking) {
            return ['error' => true, 'message' => 'Booking not found.'];
        }

        $user = Auth::user();
        if (!$user || $booking->customer_id !== $user->id) {
            return ['error' => true, 'message' => 'Unauthorized access to this booking.'];
        }
        $paymentMethod = $this->resolveCustomerPaymentMethod($user->id, $userPaymentMethodId);
        if (!$paymentMethod) {
            return ['error' => true, 'message' => 'No saved payment method found.'];
        }

        $amountCents = (int) round($booking->total_price * 100);
        if ($amountCents <= 0) {
            return ['error' => true, 'message' => 'Invalid booking amount.'];
        }

        $currency = strtolower(Setting::get('currency', 'USD'));

        try {
            $customerId = $this->stripe->ensureCustomer($user);
            $intent = $this->stripe->chargeCustomer(
                customerId: $customerId,
                paymentMethodId: $paymentMethod->stripe_payment_method_id,
                amountCents: $amountCents,
                currency: $currency,
                metadata: [
                    'booking_id' => (string)$booking->id,
                    'customer_id' => (string)$user->id,
                    'provider_id' => (string)$booking->provider_id,
                ],
                offSession: true,
                confirm: true
            );
        } catch (\Stripe\Exception\CardException $e) {
            $errCode = $e->getError()->code ?? null;

            // Retry logic if payment method requires new method
            if ($errCode === 'authentication_required' || $errCode === 'card_declined') {
                return [
                    'error' => true,
                    'requires_payment_method' => true,
                    'message' => $e->getError()->message ?? 'Payment requires a new card.',
                    'stripe_intent_client_secret' => $e->getError()->payment_intent->client_secret ?? null,
                ];
            }

            Log::error('Booking payment failed: '.$e->getMessage(), ['booking_id' => $booking->id]);
            return ['error' => true, 'message' => 'Stripe error: '.$e->getMessage()];
        } catch (\Throwable $e) {
            Log::error('Booking payment failed: '.$e->getMessage(), ['booking_id' => $booking->id]);
            return ['error' => true, 'message' => 'Stripe error: '.$e->getMessage()];
        }

        if ($intent->status === 'requires_payment_method') {
            return [
                'error' => true,
                'requires_payment_method' => true,
                'message' => 'Payment requires a new payment method.',
                'stripe_intent_client_secret' => $intent->client_secret
            ];
        }

        $charge = $intent->charges->data[0] ?? null;
        $intentMetadata = $intent->metadata ?? [];
        if (!is_array($intentMetadata)) {
            $intentMetadata = (array) $intentMetadata;
        }

        $transaction = Transaction::create([
            'booking_id' => $booking->id,
            'customer_id' => $user->id,
            'provider_id' => $booking->provider_id,
            'transaction_ref' => Transaction::generateRef(),
            'type' => 'payment',
            'status' => 'succeeded',
            'amount' => $booking->total_price,
            'service_charges' => $booking->service_charges ?? 0,
            'net_amount' => max(0, $booking->total_price - ($booking->service_charges ?? 0)),
            'currency' => strtoupper($currency),
            'stripe_payment_intent_id' => $intent->id,
            'stripe_payment_method_id' => $paymentMethod->stripe_payment_method_id,
            'stripe_charge_id' => $charge->id ?? null,
            'stripe_customer_id' => $customerId,
            'processed_at' => now(),
            'completed_at' => now(),
            'metadata' => [
                'booking_id' => $booking->id,
                'customer_id' => $user->id,
                'provider_id' => $booking->provider_id,
            ],
            'notes' => 'Charged via saved card (off-session).',
        ]);

        $booking->update([
            'paid_at' => now(),
            'stripe_payment_intent_id' => $intent->id,
            'stripe_payment_method_id' => $paymentMethod->stripe_payment_method_id,
        ]);

        $this->notificationService->notifyPaymentSuccess($transaction);

        return ['error' => false, 'message' => 'Payment processed successfully.', 'transaction' => $transaction];
    }
    public function onGoingBookingsCustomer($customerId)
    {
        return Booking::with('slots', 'provider', 'customer','providerService.service')->where('customer_id', $customerId)->where('status', 'in_progress')->paginate(10);
    }

    /**
     * Check if review has been given for a booking
     * 
     * @param int|Booking $booking
     * @return bool
     */
    public function isReviewGiven($booking): bool
    {
        if ($booking instanceof Booking) {
            return $booking->review()->exists();
        }
        
        return Review::where('booking_id', $booking)->exists();
    }

    /**
     * Add is_review_given status to booking(s)
     * 
     * @param Booking|\Illuminate\Database\Eloquent\Collection $bookings
     * @return Booking|\Illuminate\Database\Eloquent\Collection
     */
    public function addReviewStatus($bookings)
    {
        if ($bookings instanceof Booking) {
            $bookings->setAttribute('is_review_given', $this->isReviewGiven($bookings));
            return $bookings;
        }

        // For collections/paginated results
        $bookingIds = $bookings->pluck('id')->toArray();
        $reviewedBookingIds = Review::whereIn('booking_id', $bookingIds)
            ->pluck('booking_id')
            ->toArray();

        foreach ($bookings as $booking) {
            $booking->setAttribute('is_review_given', in_array($booking->id, $reviewedBookingIds));
        }

        return $bookings;
    }

    /**
     * Check if provider is late for an upcoming booking
     * 
     * @param Booking $booking
     * @param int $lateMinutesThreshold Minutes after start time to consider late (default: 15)
     * @return array
     */
    public function isProviderLate(Booking $booking, int $lateMinutesThreshold = 15): array
    {
        // Only check for confirmed/upcoming bookings
        if (!in_array($booking->status, ['confirmed'])) {
            return [
                'is_late' => false,
                'message' => 'Booking is not in upcoming status.'
            ];
        }

        // Get the first slot (earliest date/time)
        $firstSlot = $booking->slots()
            ->orderBy('service_date', 'asc')
            ->orderBy('start_time', 'asc')
            ->first();

        if (!$firstSlot) {
            return [
                'is_late' => false,
                'message' => 'No slots found for this booking.'
            ];
        }

        // Combine date and time to create datetime
        $slotDateTime = Carbon::parse($firstSlot->service_date . ' ' . $firstSlot->start_time);
        $now = Carbon::now();

        // Check if slot time has passed
        if ($now->lt($slotDateTime)) {
            return [
                'is_late' => false,
                'message' => 'Booking time has not arrived yet.',
                'slot_datetime' => $slotDateTime->toDateTimeString(),
                'minutes_until_slot' => $now->diffInMinutes($slotDateTime, false)
            ];
        }

        // Check if provider is late (past start time + threshold)
        $lateThreshold = $slotDateTime->copy()->addMinutes($lateMinutesThreshold);
        $isLate = $now->gte($lateThreshold);
        $minutesLate = $isLate ? $now->diffInMinutes($slotDateTime, false) : 0;

        return [
            'is_late' => $isLate,
            'message' => $isLate ? 'Provider is running late.' : 'Provider is on time.',
            'slot_datetime' => $slotDateTime->toDateTimeString(),
            'minutes_late' => $minutesLate,
            'late_threshold_minutes' => $lateMinutesThreshold,
            'can_take_action' => $isLate && !$booking->late_action_taken
        ];
    }

    /**
     * Handle late action for a booking
     * 
     * @param Booking $booking
     * @param string $action 'wait', 'reschedule', or 'escalate'
     * @param array|null $newSlots Required if action is 'reschedule'
     * @return array
     */
    public function handleLateAction(Booking $booking, string $action, ?array $newSlots = null): array
    {
        // Validate booking status
        if ($booking->status !== 'confirmed') {
            return [
                'error' => true,
                'message' => 'Only confirmed/upcoming bookings can have late actions.'
            ];
        }

        // Check if action already taken
        if ($booking->late_action_taken) {
            return [
                'error' => true,
                'message' => 'Late action has already been taken for this booking.',
                'previous_action' => $booking->late_action_type
            ];
        }

        // Validate action type
        if (!in_array($action, ['wait', 'reschedule', 'escalate'])) {
            return [
                'error' => true,
                'message' => 'Invalid action. Must be: wait, reschedule, or escalate.'
            ];
        }

        // Check if provider is actually late
        $lateCheck = $this->isProviderLate($booking);
        if (!$lateCheck['is_late']) {
            return [
                'error' => true,
                'message' => 'Provider is not late. Action cannot be taken.',
                'late_check' => $lateCheck
            ];
        }

        // Handle different actions
        switch ($action) {
            case 'wait':
                // Customer chooses to wait - just mark action taken
                $booking->update([
                    'late_action_taken' => true,
                    'late_action_type' => 'wait',
                    'late_action_at' => now()
                ]);

                return [
                    'error' => false,
                    'message' => 'You have chosen to wait for the provider.',
                    'booking' => $booking->fresh(['slots', 'provider', 'customer', 'providerService.service'])
                ];

            case 'reschedule':
                // Customer wants to reschedule - use existing reschedule logic
                // if (!$newSlots || empty($newSlots)) {
                //     return [
                //         'error' => true,
                //         'message' => 'New slots are required for rescheduling.'
                //     ];
                // }

                // Use existing requestReschedule method
                $rescheduleResult = $this->requestReschedule($booking, $newSlots);
                
                // if ($rescheduleResult['error']) {
                //     return $rescheduleResult;
                // }

                // Mark late action
                $booking->update([
                    'late_action_taken' => true,
                    'late_action_type' => 'reschedule',
                    'late_action_at' => now()
                ]);

                return [
                    'error' => false,
                    'message' => 'Reschedule request sent due to provider being late.',
                    'booking' => $booking->fresh(['slots', 'provider', 'customer', 'providerService.service']),
                    // 'reschedule' => $rescheduleResult['reschedule']
                ];

            case 'escalate':
                // Escalate to admin - mark action and potentially notify admin
                $this->notificationService->notifyProviderLateEscalation($booking);
                $booking->update([
                    'late_action_taken' => true,
                    'late_action_type' => 'escalate',
                    'late_action_at' => now()
                ]);

                // Send notification to admin about escalation
                // $this->notificationService->notifyProviderLateEscalation($booking);

                return [
                    'error' => false,
                    'message' => 'Issue has been escalated. Admin will be notified.',
                    'booking' => $booking->fresh(['slots', 'provider', 'customer', 'providerService.service'])
                ];

            default:
                return [
                    'error' => true,
                    'message' => 'Invalid action type.'
                ];
        }
    }
}

<?php
namespace App\Services\Payment;

use Stripe\Stripe;
use Stripe\PaymentIntent; 
use Stripe\Exception\CardException;
use Stripe\Refund; 
use Stripe\PaymentMethod;
use Stripe\Customer;
use Stripe\SetupIntent;
use Stripe\Exception\InvalidRequestException;
use App\Models\User;

use Illuminate\Support\Facades\Log;
class StripeService
{
    public function __construct()
    {
        Stripe::setApiKey(config('services.stripe.secret'));
    }

    public function createSetupIntent(string $customerId): SetupIntent
    {
        return SetupIntent::create([
            'customer' => $customerId,
            'payment_method_types' => ['card'],
        ]);
    }
    public function setDefaultPaymentMethod(string $customerId, string $paymentMethodId): void
    {
        Customer::update($customerId, [
            'invoice_settings' => [
                'default_payment_method' => $paymentMethodId,
            ],
        ]);
    }
    public function testStripePayment(): PaymentIntent
    {
        $paymentMethod = \Stripe\PaymentMethod::create([
            'type' => 'card',
            'card' => ['token' => 'tok_visa'],
        ]); 
        // 2️⃣ Create + Confirm PaymentIntent
        return PaymentIntent::create([
            'amount' => 5000, // $50
            'currency' => 'usd',
            'payment_method' => $paymentMethod->id, // pm_xxx from tok_visa
            'confirmation_method' => 'automatic',
            'confirm' => true,             
            'payment_method_types' => ['card'], // ✅ required when disabling auto
             
        ]);

         
    } 
    public function createAndConfirmIntent(int $amountCents, string $currency , string $paymentMethodId, array $metadata = []): PaymentIntent
    { 
        return PaymentIntent::create([
            'amount' => $amountCents,
            'currency' => $currency,
            'payment_method' => $paymentMethodId,
            'confirm' => true,
            'payment_method_types' => ['card'],
            'metadata' => $metadata,  
        ]); 
       
         
        

    }

    public function refundByPaymentIntent(string $paymentIntentId): \Stripe\Refund
    {
        return Refund::create(['payment_intent' => $paymentIntentId]);
    }

    public function chargeCustomer(string $customerId, string $paymentMethodId, int $amountCents, string $currency, array $metadata = [],bool $offSession = true, bool $confirm = true): PaymentIntent
    {  
        try {
            //code...
            return PaymentIntent::create([
                'amount' => $amountCents,
                'currency' => $currency,
                'customer' => $customerId,
                'payment_method' => $paymentMethodId,
                'off_session' => $offSession,
                'confirm' => $confirm,
                'payment_method_types' => ['card'],
                'metadata' => $metadata,
            ]);
        } catch (CardException $e) {
            //throw $th;
            throw $e;
        }       
    }

    /**
     * Ensure a Stripe customer exists for the given user and return the id.
     */
    public function ensureCustomer(User $user): string
    {
        if ($user->stripe_customer_id) {
            try {
                Customer::retrieve($user->stripe_customer_id);
                return $user->stripe_customer_id;
            } catch (InvalidRequestException $e) {
                Log::warning('Stripe customer missing: ' . $e->getMessage());
                $user->update(['stripe_customer_id' => null]);
            }
        }

        $customer = Customer::create([
            'email' => $user->email,
            'name'  => $user->name,
        ]);

        $user->update(['stripe_customer_id' => $customer->id]);

        return $customer->id;
    }

    public function retryPayment(
    string $paymentIntentId,
    string $paymentMethodId
    ): PaymentIntent {
        try {
            return PaymentIntent::confirm(
                $paymentIntentId,
                [
                    'payment_method' => $paymentMethodId,
                ]
            );
        } catch (CardException $e) {
            // SCA / card issue
            throw $e;
        }
    }
    /**
     * Attach a PaymentMethod to customer and optionally set it default.
     */
    // public function attachPaymentMethod(string $customerId, string $paymentMethodId, bool $makeDefault = false): PaymentMethod
    // {
    //     $paymentMethod = PaymentMethod::retrieve($paymentMethodId);

    //     if (!empty($paymentMethod->customer) && $paymentMethod->customer !== $customerId) {
    //         throw new \RuntimeException('Payment method already attached to another customer.');
    //     }

    //     if ($paymentMethod->customer !== $customerId) {
    //         $paymentMethod->attach(['customer' => $customerId]);
    //     }

    //     if ($makeDefault) {
    //         Customer::update($customerId, [
    //             'invoice_settings' => [
    //                 'default_payment_method' => $paymentMethodId,
    //             ],
    //         ]);
    //     }

    //     return $paymentMethod;
    // }
}

